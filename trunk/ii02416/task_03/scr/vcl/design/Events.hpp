// CodeGear C++Builder
// Copyright (c) 1995, 2022 by Embarcadero Technologies, Inc.
// All rights reserved

// (DO NOT EDIT: machine generated header) 'Events.pas' rev: 35.00 (Windows)

#ifndef EventsHPP
#define EventsHPP

#pragma delphiheader begin
#pragma option push
#pragma option -w-      // All warnings off
#pragma option -Vx      // Zero-length empty class member 
#pragma pack(push,8)
#include <System.hpp>
#include <SysInit.hpp>
#include <System.Classes.hpp>
#include <System.Generics.Collections.hpp>
#include <System.SysUtils.hpp>
#include <System.Generics.Defaults.hpp>
#include <System.Types.hpp>

//-- user supplied -----------------------------------------------------------

namespace Events
{
//-- forward type declarations -----------------------------------------------
struct THandler;
class DELPHICLASS TEvent;
class DELPHICLASS TEventT;
template<typename T> class DELPHICLASS TEvent1__1;
template<typename T1, typename T2> class DELPHICLASS TEvent2__2;
template<typename T1, typename T2, typename T3> class DELPHICLASS TEvent3__3;
//-- type declarations -------------------------------------------------------
typedef THandler *PHandler;

struct DECLSPEC_DRECORD THandler
{
public:
	System::Classes::TNotifyEvent Handler;
};


#pragma pack(push,4)
class PASCALIMPLEMENTATION TEvent : public System::TObject
{
	typedef System::TObject inherited;
	
private:
	bool FExecuted;
	
protected:
	System::Classes::TList* List;
	
public:
	__fastcall TEvent();
	__fastcall virtual ~TEvent();
	void __fastcall Add(System::Classes::TNotifyEvent AHandler);
	void __fastcall ForceAdd(System::Classes::TNotifyEvent AHandler);
	virtual int __fastcall IndexOf(System::Classes::TNotifyEvent AHandler);
	void __fastcall Remove(System::Classes::TNotifyEvent AHandler);
	void __fastcall Send(System::TObject* Sender);
	void __fastcall Clear();
	__property bool Executed = {read=FExecuted, nodefault};
};

#pragma pack(pop)

#pragma pack(push,4)
class PASCALIMPLEMENTATION TEventT : public System::TObject
{
	typedef System::TObject inherited;
	
protected:
	System::Generics::Collections::TList__1<System::Classes::TNotifyEvent>* FList;
	void __fastcall InternalAdd(System::Classes::TNotifyEvent Handler);
	void __fastcall InternalRemove(System::Classes::TNotifyEvent Handler);
	
public:
	__fastcall TEventT();
	__fastcall virtual ~TEventT();
	void __fastcall Clear();
};

#pragma pack(pop)

/* [Template Alias] */
#if defined(__clang__)
template<typename T> using TNotifyEvent1__1 = void __fastcall (__closure *)(const T P);
#endif

#pragma pack(push,4)
// Template declaration generated by Delphi parameterized types is
// used only for accessing Delphi variables and fields.
// Don't instantiate with new type parameters in user code.
template<typename T> class PASCALIMPLEMENTATION TEvent1__1 : public TEventT
{
	typedef TEventT inherited;
	
public:
	typedef void __fastcall (__closure *_dt_Events_1)(const T P);
	void __fastcall Add(_dt_Events_1 Handler);
	typedef void __fastcall (__closure *_dt_Events_2)(const T P);
	void __fastcall Remove(_dt_Events_2 Handler);
	void __fastcall Send(const T P);
public:
	/* TEventT.Create */ inline __fastcall TEvent1__1() : TEventT() { }
	/* TEventT.Destroy */ inline __fastcall virtual ~TEvent1__1() { }
	
};

#pragma pack(pop)

/* [Template Alias] */
#if defined(__clang__)
template<typename T1, typename T2> using TNotifyEvent2__2 = void __fastcall (__closure *)(const T1 P1, const T2 P2);
#endif

#pragma pack(push,4)
// Template declaration generated by Delphi parameterized types is
// used only for accessing Delphi variables and fields.
// Don't instantiate with new type parameters in user code.
template<typename T1, typename T2> class PASCALIMPLEMENTATION TEvent2__2 : public TEventT
{
	typedef TEventT inherited;
	
public:
	typedef void __fastcall (__closure *_dt_Events_3)(const T1 P1, const T2 P2);
	void __fastcall Add(_dt_Events_3 Handler);
	typedef void __fastcall (__closure *_dt_Events_4)(const T1 P1, const T2 P2);
	void __fastcall Remove(_dt_Events_4 Handler);
	void __fastcall Send(const T1 P1, const T2 P2);
public:
	/* TEventT.Create */ inline __fastcall TEvent2__2() : TEventT() { }
	/* TEventT.Destroy */ inline __fastcall virtual ~TEvent2__2() { }
	
};

#pragma pack(pop)

/* [Template Alias] */
#if defined(__clang__)
template<typename T1, typename T2, typename T3> using TNotifyEvent3__3 = void __fastcall (__closure *)(const T1 P1, const T2 P2, const T3 P3);
#endif

#pragma pack(push,4)
// Template declaration generated by Delphi parameterized types is
// used only for accessing Delphi variables and fields.
// Don't instantiate with new type parameters in user code.
template<typename T1, typename T2, typename T3> class PASCALIMPLEMENTATION TEvent3__3 : public TEventT
{
	typedef TEventT inherited;
	
public:
	typedef void __fastcall (__closure *_dt_Events_5)(const T1 P1, const T2 P2, const T3 P3);
	void __fastcall Add(_dt_Events_5 Handler);
	typedef void __fastcall (__closure *_dt_Events_6)(const T1 P1, const T2 P2, const T3 P3);
	void __fastcall Remove(_dt_Events_6 Handler);
	void __fastcall Send(const T1 P1, const T2 P2, const T3 P3);
public:
	/* TEventT.Create */ inline __fastcall TEvent3__3() : TEventT() { }
	/* TEventT.Destroy */ inline __fastcall virtual ~TEvent3__3() { }
	
};

#pragma pack(pop)

//-- var, const, procedure ---------------------------------------------------
}	/* namespace Events */
#if !defined(DELPHIHEADER_NO_IMPLICIT_NAMESPACE_USE) && !defined(NO_USING_NAMESPACE_EVENTS)
using namespace Events;
#endif
#pragma pack(pop)
#pragma option pop

#pragma delphiheader end.
//-- end unit ----------------------------------------------------------------
#endif	// EventsHPP
